// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: menu/service.proto

package menu

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MenuService_CreateMenu_FullMethodName    = "/com.gastroflow.menu.MenuService/CreateMenu"
	MenuService_GetMenu_FullMethodName       = "/com.gastroflow.menu.MenuService/GetMenu"
	MenuService_UpdateMenu_FullMethodName    = "/com.gastroflow.menu.MenuService/UpdateMenu"
	MenuService_DeleteMenu_FullMethodName    = "/com.gastroflow.menu.MenuService/DeleteMenu"
	MenuService_ListMenus_FullMethodName     = "/com.gastroflow.menu.MenuService/ListMenus"
	MenuService_GetActiveMenu_FullMethodName = "/com.gastroflow.menu.MenuService/GetActiveMenu"
)

// MenuServiceClient is the client API for MenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MenuService - gRPC сервис для управления меню
type MenuServiceClient interface {
	// Создать новое меню
	CreateMenu(ctx context.Context, in *CreateMenuRequest, opts ...grpc.CallOption) (*CreateMenuResponse, error)
	// Получить меню по ID
	GetMenu(ctx context.Context, in *GetMenuRequest, opts ...grpc.CallOption) (*GetMenuResponse, error)
	// Обновить меню
	UpdateMenu(ctx context.Context, in *UpdateMenuRequest, opts ...grpc.CallOption) (*UpdateMenuResponse, error)
	// Удалить меню (мягкое удаление)
	DeleteMenu(ctx context.Context, in *DeleteMenuRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Получить список меню ресторана
	ListMenus(ctx context.Context, in *ListMenusRequest, opts ...grpc.CallOption) (*ListMenusResponse, error)
	// Получить активное меню ресторана
	GetActiveMenu(ctx context.Context, in *GetActiveMenuRequest, opts ...grpc.CallOption) (*GetActiveMenuResponse, error)
}

type menuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuServiceClient(cc grpc.ClientConnInterface) MenuServiceClient {
	return &menuServiceClient{cc}
}

func (c *menuServiceClient) CreateMenu(ctx context.Context, in *CreateMenuRequest, opts ...grpc.CallOption) (*CreateMenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMenuResponse)
	err := c.cc.Invoke(ctx, MenuService_CreateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) GetMenu(ctx context.Context, in *GetMenuRequest, opts ...grpc.CallOption) (*GetMenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMenuResponse)
	err := c.cc.Invoke(ctx, MenuService_GetMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) UpdateMenu(ctx context.Context, in *UpdateMenuRequest, opts ...grpc.CallOption) (*UpdateMenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMenuResponse)
	err := c.cc.Invoke(ctx, MenuService_UpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) DeleteMenu(ctx context.Context, in *DeleteMenuRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MenuService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) ListMenus(ctx context.Context, in *ListMenusRequest, opts ...grpc.CallOption) (*ListMenusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMenusResponse)
	err := c.cc.Invoke(ctx, MenuService_ListMenus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) GetActiveMenu(ctx context.Context, in *GetActiveMenuRequest, opts ...grpc.CallOption) (*GetActiveMenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveMenuResponse)
	err := c.cc.Invoke(ctx, MenuService_GetActiveMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServiceServer is the server API for MenuService service.
// All implementations should embed UnimplementedMenuServiceServer
// for forward compatibility.
//
// MenuService - gRPC сервис для управления меню
type MenuServiceServer interface {
	// Создать новое меню
	CreateMenu(context.Context, *CreateMenuRequest) (*CreateMenuResponse, error)
	// Получить меню по ID
	GetMenu(context.Context, *GetMenuRequest) (*GetMenuResponse, error)
	// Обновить меню
	UpdateMenu(context.Context, *UpdateMenuRequest) (*UpdateMenuResponse, error)
	// Удалить меню (мягкое удаление)
	DeleteMenu(context.Context, *DeleteMenuRequest) (*emptypb.Empty, error)
	// Получить список меню ресторана
	ListMenus(context.Context, *ListMenusRequest) (*ListMenusResponse, error)
	// Получить активное меню ресторана
	GetActiveMenu(context.Context, *GetActiveMenuRequest) (*GetActiveMenuResponse, error)
}

// UnimplementedMenuServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuServiceServer struct{}

func (UnimplementedMenuServiceServer) CreateMenu(context.Context, *CreateMenuRequest) (*CreateMenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedMenuServiceServer) GetMenu(context.Context, *GetMenuRequest) (*GetMenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenu not implemented")
}
func (UnimplementedMenuServiceServer) UpdateMenu(context.Context, *UpdateMenuRequest) (*UpdateMenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServiceServer) DeleteMenu(context.Context, *DeleteMenuRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServiceServer) ListMenus(context.Context, *ListMenusRequest) (*ListMenusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMenus not implemented")
}
func (UnimplementedMenuServiceServer) GetActiveMenu(context.Context, *GetActiveMenuRequest) (*GetActiveMenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveMenu not implemented")
}
func (UnimplementedMenuServiceServer) testEmbeddedByValue() {}

// UnsafeMenuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServiceServer will
// result in compilation errors.
type UnsafeMenuServiceServer interface {
	mustEmbedUnimplementedMenuServiceServer()
}

func RegisterMenuServiceServer(s grpc.ServiceRegistrar, srv MenuServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuService_ServiceDesc, srv)
}

func _MenuService_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_CreateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).CreateMenu(ctx, req.(*CreateMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_GetMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetMenu(ctx, req.(*GetMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_UpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).UpdateMenu(ctx, req.(*UpdateMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).DeleteMenu(ctx, req.(*DeleteMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_ListMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).ListMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_ListMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).ListMenus(ctx, req.(*ListMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_GetActiveMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetActiveMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetActiveMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetActiveMenu(ctx, req.(*GetActiveMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuService_ServiceDesc is the grpc.ServiceDesc for MenuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.gastroflow.menu.MenuService",
	HandlerType: (*MenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenu",
			Handler:    _MenuService_CreateMenu_Handler,
		},
		{
			MethodName: "GetMenu",
			Handler:    _MenuService_GetMenu_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _MenuService_UpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _MenuService_DeleteMenu_Handler,
		},
		{
			MethodName: "ListMenus",
			Handler:    _MenuService_ListMenus_Handler,
		},
		{
			MethodName: "GetActiveMenu",
			Handler:    _MenuService_GetActiveMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "menu/service.proto",
}

const (
	CategoryService_CreateCategory_FullMethodName    = "/com.gastroflow.menu.CategoryService/CreateCategory"
	CategoryService_GetCategory_FullMethodName       = "/com.gastroflow.menu.CategoryService/GetCategory"
	CategoryService_UpdateCategory_FullMethodName    = "/com.gastroflow.menu.CategoryService/UpdateCategory"
	CategoryService_DeleteCategory_FullMethodName    = "/com.gastroflow.menu.CategoryService/DeleteCategory"
	CategoryService_ListCategories_FullMethodName    = "/com.gastroflow.menu.CategoryService/ListCategories"
	CategoryService_ReorderCategories_FullMethodName = "/com.gastroflow.menu.CategoryService/ReorderCategories"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CategoryService - gRPC сервис для управления категориями
type CategoryServiceClient interface {
	// Создать новую категорию
	CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error)
	// Получить категорию по ID
	GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*GetCategoryResponse, error)
	// Обновить категорию
	UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error)
	// Удалить категорию (мягкое удаление)
	DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Получить список категорий меню
	ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
	// Изменить порядок категорий
	ReorderCategories(ctx context.Context, in *ReorderCategoriesRequest, opts ...grpc.CallOption) (*ReorderCategoriesResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) CreateCategory(ctx context.Context, in *CreateCategoryRequest, opts ...grpc.CallOption) (*CreateCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_CreateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*GetCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) UpdateCategory(ctx context.Context, in *UpdateCategoryRequest, opts ...grpc.CallOption) (*UpdateCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_UpdateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *DeleteCategoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CategoryService_DeleteCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCategoriesResponse)
	err := c.cc.Invoke(ctx, CategoryService_ListCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) ReorderCategories(ctx context.Context, in *ReorderCategoriesRequest, opts ...grpc.CallOption) (*ReorderCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReorderCategoriesResponse)
	err := c.cc.Invoke(ctx, CategoryService_ReorderCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations should embed UnimplementedCategoryServiceServer
// for forward compatibility.
//
// CategoryService - gRPC сервис для управления категориями
type CategoryServiceServer interface {
	// Создать новую категорию
	CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error)
	// Получить категорию по ID
	GetCategory(context.Context, *GetCategoryRequest) (*GetCategoryResponse, error)
	// Обновить категорию
	UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error)
	// Удалить категорию (мягкое удаление)
	DeleteCategory(context.Context, *DeleteCategoryRequest) (*emptypb.Empty, error)
	// Получить список категорий меню
	ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
	// Изменить порядок категорий
	ReorderCategories(context.Context, *ReorderCategoriesRequest) (*ReorderCategoriesResponse, error)
}

// UnimplementedCategoryServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) CreateCategory(context.Context, *CreateCategoryRequest) (*CreateCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategory(context.Context, *GetCategoryRequest) (*GetCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategory not implemented")
}
func (UnimplementedCategoryServiceServer) UpdateCategory(context.Context, *UpdateCategoryRequest) (*UpdateCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *DeleteCategoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedCategoryServiceServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCategories not implemented")
}
func (UnimplementedCategoryServiceServer) ReorderCategories(context.Context, *ReorderCategoriesRequest) (*ReorderCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReorderCategories not implemented")
}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue() {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).CreateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_CreateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).CreateCategory(ctx, req.(*CreateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategory(ctx, req.(*GetCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_UpdateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_UpdateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, req.(*UpdateCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_DeleteCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*DeleteCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).ListCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_ListCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).ListCategories(ctx, req.(*ListCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_ReorderCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReorderCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).ReorderCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_ReorderCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).ReorderCategories(ctx, req.(*ReorderCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.gastroflow.menu.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCategory",
			Handler:    _CategoryService_CreateCategory_Handler,
		},
		{
			MethodName: "GetCategory",
			Handler:    _CategoryService_GetCategory_Handler,
		},
		{
			MethodName: "UpdateCategory",
			Handler:    _CategoryService_UpdateCategory_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _CategoryService_DeleteCategory_Handler,
		},
		{
			MethodName: "ListCategories",
			Handler:    _CategoryService_ListCategories_Handler,
		},
		{
			MethodName: "ReorderCategories",
			Handler:    _CategoryService_ReorderCategories_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "menu/service.proto",
}

const (
	MenuItemService_CreateMenuItem_FullMethodName       = "/com.gastroflow.menu.MenuItemService/CreateMenuItem"
	MenuItemService_GetMenuItem_FullMethodName          = "/com.gastroflow.menu.MenuItemService/GetMenuItem"
	MenuItemService_UpdateMenuItem_FullMethodName       = "/com.gastroflow.menu.MenuItemService/UpdateMenuItem"
	MenuItemService_DeleteMenuItem_FullMethodName       = "/com.gastroflow.menu.MenuItemService/DeleteMenuItem"
	MenuItemService_ListMenuItems_FullMethodName        = "/com.gastroflow.menu.MenuItemService/ListMenuItems"
	MenuItemService_SearchMenuItems_FullMethodName      = "/com.gastroflow.menu.MenuItemService/SearchMenuItems"
	MenuItemService_UpdateMenuItemStatus_FullMethodName = "/com.gastroflow.menu.MenuItemService/UpdateMenuItemStatus"
	MenuItemService_ReorderMenuItems_FullMethodName     = "/com.gastroflow.menu.MenuItemService/ReorderMenuItems"
	MenuItemService_GetPopularMenuItems_FullMethodName  = "/com.gastroflow.menu.MenuItemService/GetPopularMenuItems"
)

// MenuItemServiceClient is the client API for MenuItemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MenuItemService - gRPC сервис для управления позициями меню
type MenuItemServiceClient interface {
	// Создать новую позицию меню
	CreateMenuItem(ctx context.Context, in *CreateMenuItemRequest, opts ...grpc.CallOption) (*CreateMenuItemResponse, error)
	// Получить позицию меню по ID
	GetMenuItem(ctx context.Context, in *GetMenuItemRequest, opts ...grpc.CallOption) (*GetMenuItemResponse, error)
	// Обновить позицию меню
	UpdateMenuItem(ctx context.Context, in *UpdateMenuItemRequest, opts ...grpc.CallOption) (*UpdateMenuItemResponse, error)
	// Удалить позицию меню (мягкое удаление)
	DeleteMenuItem(ctx context.Context, in *DeleteMenuItemRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Получить список позиций категории
	ListMenuItems(ctx context.Context, in *ListMenuItemsRequest, opts ...grpc.CallOption) (*ListMenuItemsResponse, error)
	// Поиск позиций меню
	SearchMenuItems(ctx context.Context, in *SearchMenuItemsRequest, opts ...grpc.CallOption) (*SearchMenuItemsResponse, error)
	// Изменить статус позиции меню
	UpdateMenuItemStatus(ctx context.Context, in *UpdateMenuItemStatusRequest, opts ...grpc.CallOption) (*UpdateMenuItemStatusResponse, error)
	// Изменить порядок позиций в категории
	ReorderMenuItems(ctx context.Context, in *ReorderMenuItemsRequest, opts ...grpc.CallOption) (*ReorderMenuItemsResponse, error)
	// Получить популярные позиции
	GetPopularMenuItems(ctx context.Context, in *GetPopularMenuItemsRequest, opts ...grpc.CallOption) (*GetPopularMenuItemsResponse, error)
}

type menuItemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuItemServiceClient(cc grpc.ClientConnInterface) MenuItemServiceClient {
	return &menuItemServiceClient{cc}
}

func (c *menuItemServiceClient) CreateMenuItem(ctx context.Context, in *CreateMenuItemRequest, opts ...grpc.CallOption) (*CreateMenuItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMenuItemResponse)
	err := c.cc.Invoke(ctx, MenuItemService_CreateMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) GetMenuItem(ctx context.Context, in *GetMenuItemRequest, opts ...grpc.CallOption) (*GetMenuItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMenuItemResponse)
	err := c.cc.Invoke(ctx, MenuItemService_GetMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) UpdateMenuItem(ctx context.Context, in *UpdateMenuItemRequest, opts ...grpc.CallOption) (*UpdateMenuItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMenuItemResponse)
	err := c.cc.Invoke(ctx, MenuItemService_UpdateMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) DeleteMenuItem(ctx context.Context, in *DeleteMenuItemRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MenuItemService_DeleteMenuItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) ListMenuItems(ctx context.Context, in *ListMenuItemsRequest, opts ...grpc.CallOption) (*ListMenuItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMenuItemsResponse)
	err := c.cc.Invoke(ctx, MenuItemService_ListMenuItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) SearchMenuItems(ctx context.Context, in *SearchMenuItemsRequest, opts ...grpc.CallOption) (*SearchMenuItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchMenuItemsResponse)
	err := c.cc.Invoke(ctx, MenuItemService_SearchMenuItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) UpdateMenuItemStatus(ctx context.Context, in *UpdateMenuItemStatusRequest, opts ...grpc.CallOption) (*UpdateMenuItemStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMenuItemStatusResponse)
	err := c.cc.Invoke(ctx, MenuItemService_UpdateMenuItemStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) ReorderMenuItems(ctx context.Context, in *ReorderMenuItemsRequest, opts ...grpc.CallOption) (*ReorderMenuItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReorderMenuItemsResponse)
	err := c.cc.Invoke(ctx, MenuItemService_ReorderMenuItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuItemServiceClient) GetPopularMenuItems(ctx context.Context, in *GetPopularMenuItemsRequest, opts ...grpc.CallOption) (*GetPopularMenuItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPopularMenuItemsResponse)
	err := c.cc.Invoke(ctx, MenuItemService_GetPopularMenuItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuItemServiceServer is the server API for MenuItemService service.
// All implementations should embed UnimplementedMenuItemServiceServer
// for forward compatibility.
//
// MenuItemService - gRPC сервис для управления позициями меню
type MenuItemServiceServer interface {
	// Создать новую позицию меню
	CreateMenuItem(context.Context, *CreateMenuItemRequest) (*CreateMenuItemResponse, error)
	// Получить позицию меню по ID
	GetMenuItem(context.Context, *GetMenuItemRequest) (*GetMenuItemResponse, error)
	// Обновить позицию меню
	UpdateMenuItem(context.Context, *UpdateMenuItemRequest) (*UpdateMenuItemResponse, error)
	// Удалить позицию меню (мягкое удаление)
	DeleteMenuItem(context.Context, *DeleteMenuItemRequest) (*emptypb.Empty, error)
	// Получить список позиций категории
	ListMenuItems(context.Context, *ListMenuItemsRequest) (*ListMenuItemsResponse, error)
	// Поиск позиций меню
	SearchMenuItems(context.Context, *SearchMenuItemsRequest) (*SearchMenuItemsResponse, error)
	// Изменить статус позиции меню
	UpdateMenuItemStatus(context.Context, *UpdateMenuItemStatusRequest) (*UpdateMenuItemStatusResponse, error)
	// Изменить порядок позиций в категории
	ReorderMenuItems(context.Context, *ReorderMenuItemsRequest) (*ReorderMenuItemsResponse, error)
	// Получить популярные позиции
	GetPopularMenuItems(context.Context, *GetPopularMenuItemsRequest) (*GetPopularMenuItemsResponse, error)
}

// UnimplementedMenuItemServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuItemServiceServer struct{}

func (UnimplementedMenuItemServiceServer) CreateMenuItem(context.Context, *CreateMenuItemRequest) (*CreateMenuItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenuItem not implemented")
}
func (UnimplementedMenuItemServiceServer) GetMenuItem(context.Context, *GetMenuItemRequest) (*GetMenuItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuItem not implemented")
}
func (UnimplementedMenuItemServiceServer) UpdateMenuItem(context.Context, *UpdateMenuItemRequest) (*UpdateMenuItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenuItem not implemented")
}
func (UnimplementedMenuItemServiceServer) DeleteMenuItem(context.Context, *DeleteMenuItemRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenuItem not implemented")
}
func (UnimplementedMenuItemServiceServer) ListMenuItems(context.Context, *ListMenuItemsRequest) (*ListMenuItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMenuItems not implemented")
}
func (UnimplementedMenuItemServiceServer) SearchMenuItems(context.Context, *SearchMenuItemsRequest) (*SearchMenuItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchMenuItems not implemented")
}
func (UnimplementedMenuItemServiceServer) UpdateMenuItemStatus(context.Context, *UpdateMenuItemStatusRequest) (*UpdateMenuItemStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenuItemStatus not implemented")
}
func (UnimplementedMenuItemServiceServer) ReorderMenuItems(context.Context, *ReorderMenuItemsRequest) (*ReorderMenuItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReorderMenuItems not implemented")
}
func (UnimplementedMenuItemServiceServer) GetPopularMenuItems(context.Context, *GetPopularMenuItemsRequest) (*GetPopularMenuItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPopularMenuItems not implemented")
}
func (UnimplementedMenuItemServiceServer) testEmbeddedByValue() {}

// UnsafeMenuItemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuItemServiceServer will
// result in compilation errors.
type UnsafeMenuItemServiceServer interface {
	mustEmbedUnimplementedMenuItemServiceServer()
}

func RegisterMenuItemServiceServer(s grpc.ServiceRegistrar, srv MenuItemServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuItemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuItemService_ServiceDesc, srv)
}

func _MenuItemService_CreateMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).CreateMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_CreateMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).CreateMenuItem(ctx, req.(*CreateMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_GetMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).GetMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_GetMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).GetMenuItem(ctx, req.(*GetMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_UpdateMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).UpdateMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_UpdateMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).UpdateMenuItem(ctx, req.(*UpdateMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_DeleteMenuItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMenuItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).DeleteMenuItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_DeleteMenuItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).DeleteMenuItem(ctx, req.(*DeleteMenuItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_ListMenuItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMenuItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).ListMenuItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_ListMenuItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).ListMenuItems(ctx, req.(*ListMenuItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_SearchMenuItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMenuItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).SearchMenuItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_SearchMenuItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).SearchMenuItems(ctx, req.(*SearchMenuItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_UpdateMenuItemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuItemStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).UpdateMenuItemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_UpdateMenuItemStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).UpdateMenuItemStatus(ctx, req.(*UpdateMenuItemStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_ReorderMenuItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReorderMenuItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).ReorderMenuItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_ReorderMenuItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).ReorderMenuItems(ctx, req.(*ReorderMenuItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuItemService_GetPopularMenuItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPopularMenuItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuItemServiceServer).GetPopularMenuItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuItemService_GetPopularMenuItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuItemServiceServer).GetPopularMenuItems(ctx, req.(*GetPopularMenuItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuItemService_ServiceDesc is the grpc.ServiceDesc for MenuItemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuItemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "com.gastroflow.menu.MenuItemService",
	HandlerType: (*MenuItemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenuItem",
			Handler:    _MenuItemService_CreateMenuItem_Handler,
		},
		{
			MethodName: "GetMenuItem",
			Handler:    _MenuItemService_GetMenuItem_Handler,
		},
		{
			MethodName: "UpdateMenuItem",
			Handler:    _MenuItemService_UpdateMenuItem_Handler,
		},
		{
			MethodName: "DeleteMenuItem",
			Handler:    _MenuItemService_DeleteMenuItem_Handler,
		},
		{
			MethodName: "ListMenuItems",
			Handler:    _MenuItemService_ListMenuItems_Handler,
		},
		{
			MethodName: "SearchMenuItems",
			Handler:    _MenuItemService_SearchMenuItems_Handler,
		},
		{
			MethodName: "UpdateMenuItemStatus",
			Handler:    _MenuItemService_UpdateMenuItemStatus_Handler,
		},
		{
			MethodName: "ReorderMenuItems",
			Handler:    _MenuItemService_ReorderMenuItems_Handler,
		},
		{
			MethodName: "GetPopularMenuItems",
			Handler:    _MenuItemService_GetPopularMenuItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "menu/service.proto",
}
